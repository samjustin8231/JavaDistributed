# SpringCloud工作原理

讲解原理一定要结合画图来说明。

Eureka, Ribbon, Feign, Zuul

## Eureka服务注册中心原理

注册中心： 服务注册表

服务：启动的时候，进行服务注册(注册到服务注册表中)

多级缓存： 服务注册表，ReadWrite缓存，ReadOnly缓存
为什么用多级缓存？避免了服务注册中心读写的并发冲突问题，如果不用多级换内存，就得通过加锁的方式来解决。

新服务注册进来时，会注册到注册表中，然后同步到ReadWrite缓存中。

ReadOnly缓存通过定时30s拉取进行同步，也就是说，服务消费者不能立马感知到服务提供者的信息。需要等到定时拉取配置的时候，同时ReadOnly缓存已经更新的话，才能感知到新的服务。

客户端会定时30s从ReadOnly缓存拉取注册信息。

Eureka注册中心的默认配置会发现一个问题：服务启动后，生产者发现的比较慢。

服务启动后，会通过心跳来维持连接。注册中心会定时检查每个服务是否没有心跳了(连续90s没有心跳)。如果发现某个服务挂了，会将注册表中的和ReadWrite缓存中该服务的信息清除。

ReadOnly缓存是通过定时任务去同步检查更新的。

### Eureka注册中心集群原理
如果我们只配置一个Eureka服务端，那么如果这个服务端崩盘，那么所有服务都无法获取，这肯定不是我们不期望的。所以为了保证高可用性，我们需要搭建Eureka集群。

前面讲原理时已经提到Eureka Server在启动时默认会注册自己，成为一个服务，所以Eureka Server也是一个客户端。也就是说们我们可以配置多个Eureka Server，让他们之间相互注册，当服务提供者向其中一个Eureka注册服务时，这个服务就会被共享到其他Eureka上，这样所有的Eureka都会有相同的服务。



## Ribbon和Feign工作原理
其实SpringCloud对外发布接口，实际上就是支持Http协议的，对外发布的就是一个最普通的Spring MVC的http接口。

通过对接口加上注解，然后对加上注解的接口生成动态代理；然后针对Feign动态代理去调用方法的时候，会在底层生成Http协议格式的请求。

底层的话，使用Http通信的框架组件，HttpClient，先使用Ribbon去从本地的Eureka注册表的缓存里获取对方机器列表，然后进行负载均衡，选择一台机器出来，然后针对该机器发送请求。

## Zuul网关工作原理

配置不同的请求路径和服务的对应关系，请求到了网关，直接查找到对应的服务，然后将请求发送到对应的服务的某台机器上。Ribbon从Eureka本地缓存列表中获取一台机器，负载均衡，将请求用Http通信框架发送到指定的机器上去。









